-- ==============================================================
-- File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2013.4
-- Copyright (C) 2013 Xilinx Inc. All rights reserved.
-- 
-- ==============================================================


library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity toplevel_udiv_8ns_8ns_8_11_div is
  port (
    clk: in std_logic;
    reset : in std_logic;
    ce : in std_logic;
    start : in std_logic;
    dividend: in std_logic_vector(7 downto 0);
    divisor: in std_logic_vector(7 downto 0);
    quot: out std_logic_vector(7 downto 0);
    remd: out std_logic_vector(7 downto 0));
end entity;

architecture rtl of toplevel_udiv_8ns_8ns_8_11_div is
  signal divisor_tmp, dividend_tmp, quot_tmp, remd_tmp, comb_tmp, quot_o, remd_o : std_logic_vector(7 downto 0);
  signal divisor_tmp_mux, dividend_tmp_mux, quot_tmp_mux, remd_tmp_mux : std_logic_vector(7 downto 0);
  signal cal_tmp : std_logic_vector(8 downto 0);
  signal sign_tmp : std_logic_vector(1 downto 0);
  signal do_start, ce0 : std_logic := '0';
  signal dividend0 : std_logic_vector(7 downto 0);
  signal divisor0 : std_logic_vector(7 downto 0);
  signal sel : std_logic := '0';
  signal cnt : std_logic_vector(7 downto 0);
begin

  sel               <=  '0' when (cnt = 0) else
                        '1';
  dividend_tmp_mux  <=  dividend_tmp when (sel = '1') else
                        dividend0;
  divisor_tmp_mux   <=  divisor_tmp when (sel = '1') else
                        divisor0;
  quot_tmp_mux      <=  quot_tmp when (sel = '1') else
                        (others => '0');
  remd_tmp_mux      <=  remd_tmp when (sel = '1') else
                        (others => '0');

  comb_tmp <= remd_tmp_mux(6 downto 0) & dividend_tmp_mux(7);
  cal_tmp <= ('0' & comb_tmp) - ('0' & divisor_tmp_mux);

  quot <= quot_o when (ce0 = '1') else (others => '0');
  remd <= remd_o when (ce0 = '1') else (others => '0');

  state: process (clk)
  begin
      if clk'event and clk = '1' then
          if reset = '1' then
              ce0 <= '0';
          else
              ce0 <= ce;
          end if;
      end if;
  end process;

  counter: process (clk)
  begin
    if clk'event and clk = '1' then
      if reset = '1' then
        cnt   <=  conv_std_logic_vector(0, 8);
      else
        if cnt  /= 8 and (sel = '1' or do_start = '1') then
          cnt   <=  cnt + '1';
        elsif cnt = 8 then
          cnt   <=  conv_std_logic_vector(0, 8);
        end if;
      end if;
    end if;
  end process;

  tran0 : process (clk)
  begin
    if (clk'event and clk='1') then
      do_start <= start;
      divisor0 <= divisor;
      dividend0 <= dividend;
    end if;
  end process;

  divisor_tran : process (clk)
  begin
    if (clk'event and clk='1') then
      divisor_tmp <= divisor_tmp_mux;
    end if;
  end process;

  dividend_tran : process (clk)
  begin
    if (clk'event and clk='1') then
      dividend_tmp <= dividend_tmp_mux(6 downto 0) & '0';
    end if;
  end process;

  remain_trans :  process (clk)
  begin
    if (clk'event and clk='1') then
      if (cal_tmp(8)='0') then
        remd_tmp <= cal_tmp(7 downto 0);
      else
        remd_tmp <= comb_tmp;
      end if;
    end if;
  end process;

  ret_trans : process (clk)
  begin
    if (clk'event and clk='1') then
      quot_tmp <= quot_tmp_mux(6 downto 0) & not cal_tmp(8);
    end if;
  end process;

  remain_out : process (clk)
  begin
    if (clk'event and clk='1') then
      if (cnt = 8) then
        remd_o <= remd_tmp;
      else
        remd_o <= remd_o;
      end if;
    end if;
  end process;

  ret_out : process (clk)
  begin
    if (clk'event and clk='1') then
      if (cnt = 8) then
        quot_o <= quot_tmp;
      else
        quot_o <= quot_o;
      end if;
    end if;
  end process;
end architecture;


Library IEEE;
use IEEE.std_logic_1164.all;

entity toplevel_udiv_8ns_8ns_8_11 is
    generic (
        ID : INTEGER;
        NUM_STAGE : INTEGER;
        din0_WIDTH : INTEGER;
        din1_WIDTH : INTEGER;
        dout_WIDTH : INTEGER);
    port (
        clk : IN STD_LOGIC;
        reset : IN STD_LOGIC;
        ce : IN STD_LOGIC;
        start : IN STD_LOGIC;
        din0 : IN STD_LOGIC_VECTOR(din0_WIDTH - 1 DOWNTO 0);
        din1 : IN STD_LOGIC_VECTOR(din1_WIDTH - 1 DOWNTO 0);
        dout : OUT STD_LOGIC_VECTOR(dout_WIDTH - 1 DOWNTO 0));
end entity;

architecture arch of toplevel_udiv_8ns_8ns_8_11 is
    component toplevel_udiv_8ns_8ns_8_11_div is
        port (
            dividend : IN STD_LOGIC_VECTOR;
            divisor : IN STD_LOGIC_VECTOR;
            quot : OUT STD_LOGIC_VECTOR;
            remd : OUT STD_LOGIC_VECTOR;
            clk : IN STD_LOGIC;
            ce : IN STD_LOGIC;
            reset : IN STD_LOGIC;
            start : IN STD_LOGIC);
    end component;

    signal sig_quot : STD_LOGIC_VECTOR(dout_WIDTH - 1 DOWNTO 0);
    signal sig_remd : STD_LOGIC_VECTOR(dout_WIDTH - 1 DOWNTO 0);



begin
    toplevel_udiv_8ns_8ns_8_11_div_U :  component toplevel_udiv_8ns_8ns_8_11_div
    port map (
        dividend => din0,
        divisor => din1,
        quot => dout,
        remd => sig_remd,
        clk => clk,
        ce => ce,
        reset => reset,
        start => start);

end architecture;


