// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2013.4
// Copyright (C) 2013 Xilinx Inc. All rights reserved.
// 
// ==============================================================


`timescale 1 ns / 1 ps

module toplevel_sdiv_9s_9ns_9_12_div_u
#(parameter
        W       =       8
)
(
        input                   clk,
        input                   reset,
        input                   ce,
        input                   start,
        input           [W-1:0] dividend,
        input           [W-1:0] divisor,
        input           [1:0]   sign_i,
        output  wire    [1:0]   sign_o,
        output  wire    [W-1:0] quot,
        output  wire    [W-1:0] remd
);
//------------------------Local signal-------------------
reg             do_start = 0;
reg             ce0      = 0;
reg     [W-1:0] dividend0;
reg     [W-1:0] divisor0;
reg     [1:0]   sign0;
reg     [W-1:0] dividend_tmp;
reg     [W-1:0] divisor_tmp;
reg     [W-1:0] quot_tmp;
reg     [W-1:0] quot_o;
reg     [W-1:0] remd_tmp;
reg     [W-1:0] remd_o;
wire    [W-1:0] dividend_tmp_mux;
wire    [W-1:0] divisor_tmp_mux;
wire    [W-1:0] quot_tmp_mux;
wire    [W-1:0] remd_tmp_mux;
wire    [W-1:0] comb_tmp;
wire    [W:0]   cal_tmp;
//------------------------Body---------------------------
assign  quot    = (ce0==1'b1)?quot_o:{W{1'b0}};
assign  remd    = (ce0==1'b1)?remd_o:{W{1'b0}};
assign  sign_o  =       sign0;

// ce0
always @ (posedge clk) begin
        if(reset == 1'b1)
            ce0             <=      1'b0;
        else
            ce0             <=      ce;
end

// dividend0, divisor0
always @(posedge clk)
begin
    dividend0       <=      dividend;
    divisor0        <=      divisor;
    sign0           <=      sign_i;
    do_start        <=      start;
end

// Counter
reg     [W-1:0]     cnt;
wire                sel;
assign  sel    =    (cnt != {W{1'b0}});
always @ (posedge clk) begin
    if (reset == 1'b1) begin
        cnt     <=      {W{1'b0}};
    end
    else begin
        if (cnt != W && (sel || do_start)) begin
            cnt         <=     cnt + 1'b1;
        end
        else if (cnt == W) begin
            cnt         <=     {W{1'b0}};
        end
    end
end

// MUXs
assign  dividend_tmp_mux    =       sel? dividend_tmp:dividend0;
assign  divisor_tmp_mux     =       sel? divisor_tmp:divisor0;
assign  quot_tmp_mux        =       sel? quot_tmp:{W{1'b0}};
assign  remd_tmp_mux        =       sel? remd_tmp:{W{1'b0}};

assign  comb_tmp     =       {remd_tmp_mux[W-2:0], dividend_tmp_mux[W-1]};
assign  cal_tmp      =       {1'b0, comb_tmp} - {1'b0, divisor_tmp_mux};
always @(posedge clk) begin
    dividend_tmp       <=      {dividend_tmp_mux[W-2:0], 1'b0};
    divisor_tmp        <=      divisor_tmp_mux;
    quot_tmp           <=      {quot_tmp_mux[W-2:0], ~cal_tmp[W]};
    remd_tmp           <=      cal_tmp[W]? comb_tmp : cal_tmp[W-1:0];
end

// Output reg
always @(posedge clk) begin
    if (cnt == W)
    begin
        quot_o      <=       quot_tmp;
        remd_o      <=       remd_tmp;
    end
    else
    begin
        quot_o      <=       quot_o;
        remd_o      <=       remd_o;
    end
end

endmodule


module toplevel_sdiv_9s_9ns_9_12_div
#(parameter
        M       =       9,
        N       =       9,
        W       =       M > N ? M : N
)
(
        input                   clk,
        input                   reset,
        input                   ce,
        input                   start,
        input           [M-1:0] dividend,
        input           [N-1:0] divisor,
        output  wire    [W-1:0] quot,
        output  wire    [W-1:0] remd
);
//------------------------Local signal-------------------
reg             ce0;
reg             start0;
reg     [M-1:0] dividend0;
reg     [N-1:0] divisor0;
wire    [M-2:0] dividend_t;
wire    [N-2:0] divisor_t;
wire    [W-2:0] dividend_u;
wire    [W-2:0] divisor_u;
wire    [W-2:0] quot_u;
wire    [W-2:0] remd_u;
wire    [1:0]   sign_i;
wire    [1:0]   sign_o;
//------------------------Instantiation------------------
toplevel_sdiv_9s_9ns_9_12_div_u #(
    .W      ( W - 1 )
) toplevel_sdiv_9s_9ns_9_12_div_u_0 (
    .clk      ( clk ),
    .reset    ( reset ),
    .ce       ( ce0 ),
    .start    ( start0 ),
    .dividend ( dividend_u ),
    .divisor  ( divisor_u ),
    .sign_i   ( sign_i ),
    .sign_o   ( sign_o ),
    .quot     ( quot_u ),
    .remd     ( remd_u )
);
//------------------------Body---------------------------
assign sign_i     = {dividend0[M-1] ^ divisor0[N-1], dividend0[M-1]};
assign dividend_t = dividend0[M-1]? ~dividend0[M-2:0] + 1'b1 :
                                    dividend0[M-2:0];
assign divisor_t  = divisor0[N-1]?  ~divisor0[N-2:0] + 1'b1 :
                                    divisor0[N-2:0];
assign dividend_u = dividend_t;
assign divisor_u  = divisor_t;
assign quot       = sign_o[1]?     ~{1'b0, quot_u} + 1'b1 :
                                   {1'b0, quot_u};
assign remd       = sign_o[0]?     ~{1'b0, remd_u} + 1'b1 :
                                   {1'b0, remd_u};

always @(posedge clk)
begin
        ce0             <=      ce;
        start0          <=      start;
        dividend0       <=      dividend;
        divisor0        <=      divisor;
end

endmodule

`timescale 1 ns / 1 ps
module toplevel_sdiv_9s_9ns_9_12(
    clk,
    reset,
    ce,
    start,
    din0,
    din1,
    dout);

parameter ID = 32'd1;
parameter NUM_STAGE = 32'd1;
parameter din0_WIDTH = 32'd1;
parameter din1_WIDTH = 32'd1;
parameter dout_WIDTH = 32'd1;
input clk;
input reset;
input ce;
input start;
input[din0_WIDTH - 1:0] din0;
input[din1_WIDTH - 1:0] din1;
output[dout_WIDTH - 1:0] dout;

wire[dout_WIDTH - 1:0] sig_remd;



toplevel_sdiv_9s_9ns_9_12_div toplevel_sdiv_9s_9ns_9_12_div_U(
    .dividend( din0 ),
    .divisor( din1 ),
    .quot( dout ),
    .remd( sig_remd ),
    .clk( clk ),
    .ce( ce ),
    .reset( reset ),
    .start( start ));

endmodule

